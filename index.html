<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Pic2SearchPdf: 이미지 PDF & OCR 변환기 (HEIC 지원, 드래그 순서 조정)
    </title>
    <meta
      name="description"
      content="Pic2SearchPdf는 HEIC, JPG, PNG 등 다양한 이미지를 OCR 텍스트 인식 기능이 포함된 검색 가능한 PDF로 변환해주는 무료 온라인 도구입니다. 드래그앤드롭으로 간편하게 파일 순서를 조정하고, 한글/영어 등 다양한 언어의 텍스트를 추출하세요."
    />
    <meta
      name="keywords"
      content="이미지 PDF, OCR 변환, HEIC PDF, HEIF PDF, JPG PDF, PNG PDF, 사진 텍스트 추출, 무료 OCR, 온라인 PDF 변환, 문서 스캔 PDF, 아이폰 사진 PDF, 한글 OCR, 영어 OCR, 검색 가능한 PDF"
    />
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <style>
      /* 기존 CSS 유지 및 개선 (미리보기, 로컬스토리지 관련 UI 추가) */
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #f2f5f9;
        color: #333;
        margin: 0;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }
      h1 {
        font-size: 2.2rem;
        margin-bottom: 0.8rem;
        text-align: center;
        color: #0070f3;
      }
      p {
        font-size: 1.1rem;
        margin-bottom: 1.5rem;
        max-width: 700px;
        text-align: center;
        line-height: 1.6;
      }
      #dropZone {
        width: 100%;
        max-width: 650px;
        height: 180px;
        border: 3px dashed #a0d0ff; /* 더욱 눈에 띄는 색상 */
        border-radius: 12px;
        display: flex;
        flex-direction: column; /* 아이콘과 텍스트 정렬 */
        justify-content: center;
        align-items: center;
        cursor: pointer;
        margin: 1.5rem 0;
        background: #e6f3ff; /* 밝은 배경색 */
        user-select: none;
        transition: background 0.3s ease, border-color 0.3s ease;
      }
      #dropZone:hover {
        background: #d9ecff;
        border-color: #0070f3;
      }
      #dropZone.dragging {
        background: #cce0f5;
        border-color: #005ac1;
      }
      .drop-icon {
        font-size: 3rem; /* 아이콘 크기 키우기 */
        color: #0070f3;
        margin-bottom: 0.5rem;
      }
      input[type="file"] {
        display: none;
      }
      #fileList {
        display: grid; /* 그리드 레이아웃으로 변경 */
        grid-template-columns: repeat(
          auto-fill,
          minmax(120px, 1fr)
        ); /* 이미지 미리보기 크기 조정 */
        gap: 15px;
        margin: 1.5rem 0;
        width: 100%;
        max-width: 900px; /* 더 넓은 영역 */
        list-style: none;
        padding: 0;
      }
      .file-item {
        background: white;
        padding: 0.7rem;
        border-radius: 8px;
        border: 1px solid #ddd;
        display: flex;
        flex-direction: column; /* 세로 정렬 */
        align-items: center;
        cursor: grab;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.07);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative;
      }
      .file-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      .file-item:active {
        cursor: grabbing;
      }
      .file-preview {
        width: 100px; /* 미리보기 이미지 크기 */
        height: 100px;
        object-fit: contain; /* 비율 유지 */
        border-radius: 4px;
        margin-bottom: 0.5rem;
      }
      .file-name {
        font-size: 0.85rem;
        text-align: center;
        word-break: break-all;
        height: 2.5em; /* 두 줄까지 표시 */
        overflow: hidden;
      }
      .remove-file-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 0.8rem;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        opacity: 0.8;
        transition: opacity 0.2s ease;
      }
      .remove-file-btn:hover {
        opacity: 1;
      }
      button.convert-btn {
        background: #0070f3;
        color: white;
        padding: 1rem 2rem;
        font-size: 1.1rem;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease;
        margin-top: 1.5rem;
        user-select: none;
        box-shadow: 0 4px 10px rgba(0, 112, 243, 0.3);
      }
      button.convert-btn:hover {
        background: #005ac1;
        transform: translateY(-2px);
      }
      #output {
        margin-top: 2.5rem;
        max-width: 900px;
        width: 100%;
        text-align: left;
        background: #fff;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        white-space: pre-wrap;
      }
      .progress-container {
        width: 100%;
        max-width: 650px;
        background: #e0e0e0;
        border-radius: 8px;
        overflow: hidden;
        margin: 1.5rem 0;
        height: 25px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .progress-bar {
        height: 100%;
        width: 0;
        background: linear-gradient(
          to right,
          #0070f3,
          #00c1ff
        ); /* 그라데이션 효과 */
        transition: width 0.3s ease;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        font-size: 0.9rem;
      }
      .ocr-options {
        margin: 1.5rem 0;
        max-width: 650px;
        width: 100%;
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        border: 1px solid #eee;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }
      .ocr-options label {
        margin-right: 1.5rem;
        cursor: pointer;
        user-select: none;
        font-weight: 500;
      }
      .ocr-languages {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }
      .ocr-languages label {
        display: flex;
        align-items: center;
        font-weight: normal;
        font-size: 0.95rem;
      }
      .ocr-languages input[type="checkbox"] {
        margin-right: 6px;
        cursor: pointer;
        transform: scale(1.1);
      }
      .download-section {
        margin-top: 2rem;
        padding-top: 1.5rem;
        border-top: 1px dashed #eee;
        text-align: center;
      }
      .download-section h3 {
        color: #0070f3;
        margin-bottom: 1rem;
      }
      .download-link {
        background: #28a745; /* 다운로드 버튼 색상 */
        color: white;
        padding: 0.8rem 1.8rem;
        font-size: 1.1rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease;
        text-decoration: none; /* 링크 밑줄 제거 */
        display: inline-block;
        box-shadow: 0 4px 10px rgba(40, 167, 69, 0.3);
      }
      .download-link:hover {
        background: #218838;
        transform: translateY(-2px);
      }
      #ocrTextResult {
        background: #f8f8f8;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1.5rem;
        max-height: 400px; /* 스크롤바 */
        overflow-y: auto;
        font-size: 0.95rem;
        line-height: 1.8;
      }

      /* 반응형 디자인 */
      @media (max-width: 768px) {
        body {
          padding: 1rem;
        }
        h1 {
          font-size: 1.8rem;
        }
        p {
          font-size: 0.95rem;
        }
        #dropZone {
          height: 120px;
        }
        #fileList {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          gap: 10px;
        }
        .file-preview {
          width: 80px;
          height: 80px;
        }
        .file-name {
          font-size: 0.8rem;
        }
        .ocr-options label {
          margin-right: 1rem;
          font-size: 0.9rem;
        }
        .ocr-languages label {
          font-size: 0.85rem;
        }
        button.convert-btn {
          padding: 0.8rem 1.5rem;
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <h1>
      📸 Pic2SearchPdf: 이미지 PDF & OCR 변환기
      <span class="emoji">✨</span>
    </h1>
    <p>
      **HEIC, JPG, PNG** 등 어떤 이미지든 검색 가능한 PDF로 변환하고, 이미지 속
      텍스트를 간편하게 추출하세요! 파일을 드래그하여 순서를 자유롭게 조정하고,
      변환된 PDF와 OCR 텍스트를 즉시 다운로드할 수 있습니다.
    </p>

    <div id="dropZone">
      <span class="drop-icon">⬆️</span>
      여기에 이미지를 드래그하거나 클릭하여 선택하세요
    </div>
    <input
      type="file"
      id="fileInput"
      accept="image/*,.heic,.heif,.tiff,.bmp"
      multiple
    />

    <ul id="fileList"></ul>

    <div class="ocr-options">
      <label
        ><input type="checkbox" id="doOCR" checked /> 이미지에서 텍스트(OCR)
        추출하기</label
      >
      <div class="ocr-languages">
        <label><input type="checkbox" value="kor" checked /> 한국어</label>
        <label><input type="checkbox" value="eng" checked /> 영어</label>
        <label><input type="checkbox" value="jpn" /> 일본어</label>
        <label><input type="checkbox" value="chi_sim" /> 중국어 (간체)</label>
        <label><input type="checkbox" value="spa" /> 스페인어</label>
        <label><input type="checkbox" value="rus" /> 러시아어</label>
        <label><input type="checkbox" value="fra" /> 프랑스어</label>
        <label><input type="checkbox" value="deu" /> 독일어</label>
      </div>
    </div>

    <button class="convert-btn" onclick="startConversion()">
      📄 PDF 변환 & 텍스트 추출 시작하기
    </button>

    <div class="progress-container" style="display: none">
      <div class="progress-bar" id="progressBar">0%</div>
    </div>

    <div id="output" style="display: none">
      <div class="download-section">
        <h3>✅ 변환이 완료되었습니다!</h3>
        <a
          id="downloadPdfLink"
          class="download-link"
          href="#"
          download="Pic2SearchPdf_converted.pdf"
        >
          📥 PDF 파일 다운로드
        </a>
      </div>
      <div id="ocrTextResult" style="display: none">
        <h4>📄 OCR 인식 결과:</h4>
        <pre id="ocrExtractedText"></pre>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <script>
      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const fileList = document.getElementById("fileList");
      const outputDiv = document.getElementById("output");
      const progressContainer = document.querySelector(".progress-container");
      const progressBar = document.getElementById("progressBar");
      const doOCRCheckbox = document.getElementById("doOCR");
      const downloadPdfLink = document.getElementById("downloadPdfLink");
      const ocrTextResultDiv = document.getElementById("ocrTextResult");
      const ocrExtractedText = document.getElementById("ocrExtractedText");

      let selectedFiles = [];
      let worker; // Tesseract.js worker for better performance

      // 페이지 로드 시 로컬 스토리지에서 파일 정보 불러오기
      document.addEventListener("DOMContentLoaded", () => {
        const savedFilesJson = localStorage.getItem("pic2searchpdf_savedFiles");
        if (savedFilesJson) {
          try {
            const savedFiles = JSON.parse(savedFilesJson);
            // File 객체 자체는 로컬 스토리지에 저장할 수 없으므로, 파일명만 불러와서 UI에 표시
            // 실제 변환 시에는 사용자가 다시 파일을 업로드해야 함을 안내하거나,
            // 더 나은 UX를 위해 IndexedDB 등을 고려할 수 있으나, 여기서는 보안을 위해 단순화
            // 현재 로컬 스토리지 기능은 "이전 작업의 흔적"을 보여주는 용도로 사용
            selectedFiles = savedFiles.map((fileInfo) => ({
              name: fileInfo.name,
              type: fileInfo.type,
              size: fileInfo.size,
              lastModified: fileInfo.lastModified,
              dataUrl: fileInfo.dataUrl, // 미리보기 재생성을 위해 dataUrl도 저장
            }));
            renderFileList();
            if (selectedFiles.length > 0) {
              alert(
                "이전 작업에 업로드했던 파일 목록이 복원되었습니다. 실제 변환을 위해 다시 파일을 드래그하거나 선택해주세요."
              );
            }
          } catch (e) {
            console.error("Failed to load saved files from local storage:", e);
            localStorage.removeItem("pic2searchpdf_savedFiles");
          }
        }
      });

      // 로컬 스토리지에 파일 정보 저장 (보안을 위해 파일 내용 대신 메타데이터만 저장)
      function saveFilesToLocalStorage() {
        const fileMetadata = selectedFiles.map((file) => ({
          name: file.name,
          type: file.type,
          size: file.size,
          lastModified: file.lastModified,
          // 파일 내용 자체를 저장하지 않음. 미리보기를 위해 임시 dataUrl 저장
          dataUrl: file.dataUrl || null,
        }));
        localStorage.setItem(
          "pic2searchpdf_savedFiles",
          JSON.stringify(fileMetadata)
        );
      }

      // 드래그앤드롭 및 클릭으로 파일 선택
      dropZone.addEventListener("click", () => fileInput.click());

      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("dragging");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("dragging");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("dragging");
        const files = Array.from(e.dataTransfer.files);
        addFiles(files);
      });

      fileInput.addEventListener("change", (e) => {
        const files = Array.from(e.target.files);
        addFiles(files);
        fileInput.value = ""; // 중복 선택 방지
      });

      async function addFiles(files) {
        for (const file of files) {
          // 중복 파일명 체크 및 추가 (파일명과 사이즈가 동일한 경우)
          if (
            !selectedFiles.some(
              (f) => f.name === file.name && f.size === file.size
            )
          ) {
            // HEIC/HEIF 파일을 미리보기 위해 먼저 변환
            let dataUrl = null;
            if (
              file.type === "image/heic" ||
              file.name.toLowerCase().endsWith(".heic") ||
              file.name.toLowerCase().endsWith(".heif")
            ) {
              try {
                const reader = new FileReader();
                const arrayBuffer = await new Promise((resolve, reject) => {
                  reader.onload = () => resolve(reader.result);
                  reader.onerror = reject;
                  reader.readAsArrayBuffer(file);
                });
                const blob = new Blob([arrayBuffer]);
                const conversionResult = await heic2any({
                  blob,
                  toType: "image/jpeg",
                  quality: 0.9,
                });
                const convertedBlob =
                  conversionResult instanceof Blob
                    ? conversionResult
                    : conversionResult[0];
                dataUrl = await new Promise((resolve, reject) => {
                  const convReader = new FileReader();
                  convReader.onload = () => resolve(convReader.result);
                  convReader.onerror = reject;
                  convReader.readAsDataURL(convertedBlob);
                });
              } catch (e) {
                console.error("HEIC preview conversion failed:", e);
                dataUrl = null; // 미리보기 실패 시 null
              }
            } else if (file.type.startsWith("image/")) {
              dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
            }

            selectedFiles.push({
              file: file, // 실제 File 객체
              name: file.name,
              type: file.type,
              size: file.size,
              lastModified: file.lastModified,
              dataUrl: dataUrl, // 미리보기용 Data URL
            });
          }
        }
        renderFileList();
        outputDiv.style.display = "none";
        progressContainer.style.display = "none";
        progressBar.style.width = "0%";
        progressBar.textContent = "0%";
        saveFilesToLocalStorage(); // 파일 추가 시 로컬 스토리지에 저장
      }

      function renderFileList() {
        fileList.innerHTML = "";
        selectedFiles.forEach((fileInfo, index) => {
          const li = document.createElement("li");
          li.className = "file-item";
          li.setAttribute("data-index", index);
          li.draggable = true; // HTML Drag & Drop API 활성화
          li.innerHTML = `
            <img src="${
              fileInfo.dataUrl ||
              "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20fill%3D%22%23ccc%22%20d%3D%22M19%205v14H5V5h14m0-2H5c-1.1%200-2%20.9-2%202v14c0%201.1.9%202%202%202h14c1.1%200%202-.9%202-2V5c0-1.1-.9-2-2-2zm-4.85%206.59l-2.2-2.2a.5.5%200%200%200-.7%200L7%2014.28V17h2.72l4.63-4.63a.5.5%200%200%200%200-.7l-2.2-2.2zM15%2010c.55%200%201-.45%201-1s-.45-1-1-1s-1%20.45-1%201s.45%201%201%201z%22%2F%3E%3C%2Fsvg%3E"
            }" alt="${fileInfo.name}" class="file-preview">
            <span class="file-name">${fileInfo.name}</span>
            <button class="remove-file-btn" data-index="${index}">&times;</button>
          `;
          fileList.appendChild(li);
        });

        // 파일 삭제 버튼 이벤트 리스너 추가
        fileList.querySelectorAll(".remove-file-btn").forEach((button) => {
          button.addEventListener("click", (e) => {
            const indexToRemove = parseInt(e.target.dataset.index);
            selectedFiles.splice(indexToRemove, 1);
            renderFileList();
            saveFilesToLocalStorage(); // 삭제 후 로컬 스토리지 업데이트
            outputDiv.style.display = "none"; // 결과 영역 숨기기
            progressContainer.style.display = "none";
          });
        });
      }

      // SortableJS를 이용해 마우스 드래그로 순서 조정 가능하게 설정
      new Sortable(fileList, {
        animation: 150,
        onEnd: (evt) => {
          const oldIndex = evt.oldIndex;
          const newIndex = evt.newIndex;
          if (oldIndex === newIndex) return;
          const movedItem = selectedFiles.splice(oldIndex, 1)[0];
          selectedFiles.splice(newIndex, 0, movedItem);
          renderFileList(); // 순서 변경 후 다시 렌더링하여 data-index 업데이트
          saveFilesToLocalStorage(); // 순서 변경 후 로컬 스토리지 업데이트
          outputDiv.style.display = "none"; // 결과 영역 숨기기
          progressContainer.style.display = "none";
        },
      });

      async function startConversion() {
        if (selectedFiles.length === 0) {
          alert("최소 한 개 이상의 이미지를 선택해주세요.");
          return;
        }

        outputDiv.style.display = "none";
        progressContainer.style.display = "block";
        progressBar.style.width = "0%";
        progressBar.textContent = "0%";

        const doOCR = doOCRCheckbox.checked;
        const languageCheckboxes = document.querySelectorAll(
          ".ocr-languages input[type=checkbox]:checked"
        );
        const languages =
          Array.from(languageCheckboxes)
            .map((el) => el.value)
            .join("+") || "kor"; // 선택된 언어가 없으면 한국어 기본

        const pdfDoc = await PDFLib.PDFDocument.create();

        let fullText = "";
        let ocrProgress = 0; // OCR 진행률 추적

        // Tesseract.js worker 초기화 (한 번만)
        if (doOCR && !worker) {
          worker = await Tesseract.createWorker({
            logger: (m) => {
              if (m.status === "recognizing text" && m.progress) {
                const overallProgress = (i + m.progress) / selectedFiles.length; // 전체 이미지 대비 OCR 진행률
                progressBar.style.width = `${Math.round(
                  overallProgress * 100
                )}%`;
                progressBar.textContent = `${Math.round(
                  overallProgress * 100
                )}% 변환 중...`;
              }
            },
          });
          await worker.loadLanguage(languages);
          await worker.initialize(languages);
        } else if (doOCR && worker) {
          // 이미 워커가 있으면 언어만 다시 로드
          await worker.loadLanguage(languages);
          await worker.initialize(languages);
        }

        for (let i = 0; i < selectedFiles.length; i++) {
          progressBar.style.width = `${Math.round(
            (i / selectedFiles.length) * 100
          )}%`;
          progressBar.textContent = `${Math.round(
            (i / selectedFiles.length) * 100
          )}% 변환 중...`;

          const file = selectedFiles[i].file; // 실제 File 객체 사용
          let imageDataUrl;

          try {
            imageDataUrl = await convertFileToDataURL(file);
          } catch (err) {
            alert(`이미지 변환 중 오류 발생: ${file.name}`);
            continue;
          }

          const img = new Image();
          img.src = imageDataUrl;

          await new Promise((resolve) => (img.onload = resolve));

          let pdfImage;
          if (file.type.startsWith("image/png")) {
            pdfImage = await pdfDoc.embedPng(imageDataUrl);
          } else {
            pdfImage = await pdfDoc.embedJpg(imageDataUrl);
          }

          const page = pdfDoc.addPage([pdfImage.width, pdfImage.height]);
          page.drawImage(pdfImage, {
            x: 0,
            y: 0,
            width: pdfImage.width,
            height: pdfImage.height,
          });

          if (doOCR && worker) {
            try {
              const {
                data: { text },
              } = await worker.recognize(imageDataUrl);
              fullText += `----- [${file.name}] -----\n` + text.trim() + "\n\n";
            } catch (e) {
              console.error(`OCR 실패: ${file.name}`, e);
              fullText += `----- [${file.name}] -----\nOCR 실패\n\n`;
            }
          }
        }

        progressBar.style.width = `100%`;
        progressBar.textContent = `100% 변환 완료!`;

        // PDF 다운로드 링크 생성
        const pdfBytes = await pdfDoc.save();
        const pdfBlob = new Blob([pdfBytes], { type: "application/pdf" });
        const pdfUrl = URL.createObjectURL(pdfBlob);

        downloadPdfLink.href = pdfUrl;
        downloadPdfLink.download = "Pic2SearchPdf_converted.pdf"; // 다운로드 파일명 지정

        outputDiv.style.display = "block"; // 결과 영역 보여주기

        if (doOCR) {
          ocrTextResultDiv.style.display = "block";
          ocrExtractedText.textContent =
            fullText || "인식된 텍스트가 없습니다.";
        } else {
          ocrTextResultDiv.style.display = "none";
        }

        // Tesseract worker 종료 (리소스 해제)
        if (worker) {
          await worker.terminate();
          worker = null;
        }
      }

      async function convertFileToDataURL(file) {
        if (
          file.type === "image/heic" ||
          file.name.toLowerCase().endsWith(".heic") ||
          file.name.toLowerCase().endsWith(".heif")
        ) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async function () {
              const blob = new Blob([reader.result]);
              try {
                const conversionResult = await heic2any({
                  blob,
                  toType: "image/jpeg",
                  quality: 0.9,
                });
                const convertedBlob =
                  conversionResult instanceof Blob
                    ? conversionResult
                    : conversionResult[0];
                const convReader = new FileReader();
                convReader.onload = () => resolve(convReader.result);
                convReader.onerror = () => reject("HEIC 변환 실패");
                convReader.readAsDataURL(convertedBlob);
              } catch (e) {
                reject("HEIC 변환 중 오류: " + e.message);
              }
            };
            reader.onerror = () => reject("HEIC 파일 읽기 실패");
            reader.readAsArrayBuffer(file);
          });
        } else if (file.type.startsWith("image/")) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject("이미지 읽기 실패");
            reader.readAsDataURL(file);
          });
        } else {
          return Promise.reject("지원하지 않는 파일 형식입니다.");
        }
      }
    </script>
  </body>
</html>
